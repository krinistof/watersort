#![allow(dead_code)]

use std::error::Error;

#[derive(Debug, PartialEq)]
enum Color {
    Blue,
    Green,
    Red,
    Yellow,
    Orange,
}

#[derive(Debug)]
struct Glass {
    content: Vec<Color>,
}

impl Glass {
    fn complete(&self) -> bool {
        let content = &self.content;

        if content.len() == 0 {
            true
        } else {
            let first = content.first().unwrap();
            content.len() == 4 && content.iter().skip(1).all(|c| c == first)
        }
    }
}

impl Default for Glass {
    fn default() -> Self {
        Glass {
            content: Vec::with_capacity(4),
        }
    }
}

#[derive(Debug, Default)]
struct State {
    glasses: Vec<Glass>,
}

impl State {
    fn solved(&self) -> bool {
        self.glasses.iter().all(|g| g.complete())
    }

    fn step(&mut self, step: Pour) -> Result<(), Box<dyn Error>>{
        let source = self.glasses.get(step.from).ok_or("No source!")?;
        let destination = self.glasses.get(step.to).ok_or("No destination!")?;

        if source.content.len() == 0 {
            return Err("Nothing at source!".into());
        }

        if destination.content.len() == 4 {
            return Err("No space left in destination!".into());
        }

        if source.content.first() != destination.content.first()  {
            return Err("Not matching colors!".into());
        }

        loop {
            let source = self.glasses.get_mut(step.from).unwrap();
            let moved = source.content.pop();
            let destination = self.glasses.get_mut(step.to).unwrap();

            destination.content.push(moved.unwrap());
            
            break;
        }
        Ok(())
    }
}

#[derive(Debug)]
struct Pour {
    from: usize,
    to: usize
}

fn main() {
    let game = State::default();
    dbg!(game);
}

#[cfg(test)]
mod scenario {
    use super::*;

    #[test]
    fn last_step() {
        let mut glasses = vec![Glass::default(), Glass::default()];
        let [left, right] = glasses.as_mut_slice() else {
            todo!()
        };

        use Color::Blue;
        left.content.push(Blue);

        for _ in 0..3 {
            right.content.push(Blue);
        }

        let mut game = State { glasses };
        dbg!(&game);

        assert!(!game.solved());

        let last = Pour {from: 0, to: 1};
        game.step(last).unwrap();
        dbg!(&game);
        assert!(game.solved());
    }
}
